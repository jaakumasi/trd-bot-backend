# TRD Bot - AI-Powered Cryptocurrency Trading System
**Backend Documentation for New Developers**

---

## ğŸ¯ System Overview

An automated cryptocurrency **day trading bot** that uses AI (Google Gemini) to analyze market data and execute trades on Binance. The system follows a conservative **1% risk-per-trade strategy** with adaptive risk-reward based on support/resistance levels and multi-timeframe analysis.

**Tech Stack:** FastAPI + SQLAlchemy + PostgreSQL + Binance API + Google Gemini AI + WebSockets

---

## ğŸ“Š Complete Trade Flow

### **Step-by-Step: How a Trade Happens**

```
1. User Registration (app/api/auth.py)
   â”œâ”€â”€ POST /auth/register â†’ Creates User + TradingConfig (is_active=False by default)
   â””â”€â”€ User receives JWT token

2. User Activates Trading (app/api/trading.py)
   â”œâ”€â”€ POST /trading/start â†’ Sets is_active=True in TradingConfig
   â””â”€â”€ User now joins the trading loop

3. Main Trading Loop (app/services/trading_bot.py)
   â”œâ”€â”€ Method: trading_loop() - Runs every 5 minutes (day trading cadence)
   â”œâ”€â”€ Method: _get_active_trading_configs() - Gets users with is_active=True
   â””â”€â”€ For each active user:
       â”‚
       â”œâ”€â†’ 4. Position Check
       â”‚   â”œâ”€â”€ Method: _process_user_trading()
       â”‚   â”œâ”€â”€ Check: Does user already have an open position?
       â”‚   â””â”€â”€ YES â†’ Skip to next user | NO â†’ Continue
       â”‚
       â”œâ”€â†’ 5. Rate Limiting
       â”‚   â”œâ”€â”€ Method: _remaining_rate_limit()
       â”‚   â”œâ”€â”€ Check: Was user analyzed <5 minutes ago?
       â”‚   â””â”€â”€ YES â†’ Skip to next user | NO â†’ Continue
       â”‚
       â”œâ”€â†’ 6. Multi-Timeframe Market Data Fetch (app/services/binance_service.py)
       â”‚   â”œâ”€â”€ Method: _fetch_market_snapshot()
       â”‚   â”œâ”€â”€ Fetches 3 timeframes for comprehensive analysis:
       â”‚   â”‚   â€¢ 15-minute (100 candles) - Primary entry signals
       â”‚   â”‚   â€¢ 1-hour (168 candles) - Trend context
       â”‚   â”‚   â€¢ 5-minute (288 candles) - Entry timing precision
       â”‚   â””â”€â”€ Returns DataFrames for each timeframe
       â”‚
       â”œâ”€â†’ 7. Market Regime Analysis (app/services/market_regime_analyzer.py)
       â”‚   â”œâ”€â”€ Method: classify_market_regime()
       â”‚   â”œâ”€â”€ Analyzes: Trend strength (ADX), Volatility (ATR), Price action
       â”‚   â””â”€â”€ Returns: Regime classification + trading permission
       â”‚
       â”œâ”€â†’ 8. Multi-Timeframe AI Analysis (app/services/ai_analyzer.py)
       â”‚   â”œâ”€â”€ Method: analyze_market_data_mtf() - Multi-timeframe analysis
       â”‚   â”œâ”€â”€ Method: calculate_technical_indicators() - RSI, MACD, ADX, ATR, Bollinger Bands
       â”‚   â”œâ”€â”€ Method: _calculate_mtf_confluence() - Scores timeframe alignment (0-100)
       â”‚   â”œâ”€â”€ Method: _generate_mtf_prompt() - Includes all timeframes + user history
       â”‚   â”œâ”€â”€ Sends to Gemini AI (gemini-2.5-flash model)
       â”‚   â””â”€â”€ Returns: {"signal": "buy/sell/hold", "confidence": 0-100, "entry_price", "stop_loss", "take_profit"}
       â”‚
       â”œâ”€â†’ 9. Signal Decision
       â”‚   â”œâ”€â”€ Signal = "hold"? â†’ Skip to next user
       â”‚   â””â”€â”€ Signal = "buy" or "sell"? â†’ Continue
       â”‚
       â”œâ”€â†’ 10. Balance Check (app/services/binance_service.py)
       â”‚   â”œâ”€â”€ Method: get_account_balance()
       â”‚   â””â”€â”€ Gets USDT available balance
       â”‚
       â”œâ”€â†’ 11. Risk Validation & Adaptive R:R (app/services/risk_manager.py)
       â”‚   â”œâ”€â”€ Method: validate_trade_signal()
       â”‚   â”œâ”€â”€ Method: detect_support_resistance_levels() - Identifies S/R zones
       â”‚   â”œâ”€â”€ Method: calculate_adaptive_risk_reward() - Dynamic SL/TP placement
       â”‚   â”œâ”€â”€ Checks:
       â”‚   â”‚   â€¢ User has no open positions (1 trade at a time rule)
       â”‚   â”‚   â€¢ Daily trade limit not exceeded (max 5/day)
       â”‚   â”‚   â€¢ AI confidence â‰¥ 75% (day trading quality bar)
       â”‚   â”‚   â€¢ Sufficient account balance (â‰¥$10 USDT)
       â”‚   â”‚   â€¢ Position size follows 1% rule
       â”‚   â”‚   â€¢ Risk-reward ratio â‰¥ 1:1.5 (minimum acceptable)
       â”‚   â”‚   â€¢ Trade value â‰¥$10 and â‰¤3% of balance
       â”‚   â””â”€â”€ PASS â†’ Continue | FAIL â†’ Reject + WebSocket notification
       â”‚
       â”œâ”€â†’ 12. Trade Execution (app/services/trading_bot.py)
       â”‚   â”œâ”€â”€ Method: _execute_trade()
       â”‚   â”œâ”€â”€ Step 1: Place order on Binance with Adaptive Exits
       â”‚   â”‚   â”œâ”€â”€ File: app/services/binance_service.py
       â”‚   â”‚   â”œâ”€â”€ Method: place_order_with_oco()
       â”‚   â”‚   â”œâ”€â”€ Creates market entry order (BUY/SELL)
       â”‚   â”‚   â”œâ”€â”€ Places OCO exit order with S/R-based levels:
       â”‚   â”‚   â”‚   â€¢ Take Profit: Nearest resistance + ATR buffer (1:1.5 to 1:3 R:R)
       â”‚   â”‚   â”‚   â€¢ Stop Loss: Nearest support - ATR buffer (0.8-2.5% range)
       â”‚   â”‚   â””â”€â”€ OCO executes automatically on Binance servers
       â”‚   â”œâ”€â”€ Step 2: Create Trade record (app/models/trade.py)
       â”‚   â”‚   â””â”€â”€ Fields: symbol, side, amount, price, status='filled', ai_signal_confidence
       â”‚   â”œâ”€â”€ Step 3: Create OpenPosition record (app/models/trade.py)
       â”‚   â”‚   â””â”€â”€ Fields: trade_id, oco_order_id, entry_price, stop_loss, take_profit
       â”‚   â”œâ”€â”€ Step 4: Add to RiskManager in-memory tracking
       â”‚   â”‚   â””â”€â”€ Method: risk_manager.add_open_position()
       â”‚   â””â”€â”€ Step 5: Send WebSocket notification to user
       â”‚
       â””â”€â†’ 13. Wait 5 minutes â†’ Loop back to Step 3
```

---

## ğŸ”„ Order Placement & Tracking

### **OCO (One-Cancels-Other) Strategy**

Every trade uses OCO orders for automatic risk management:

**What Happens:**
1. **Entry Order** (Market Order)
   - Executes immediately at current price
   - File: `binance_service.py`, Method: `place_order_with_oco()`
   
2. **Exit Orders** (OCO - placed simultaneously with adaptive levels)
   - **Take Profit**: Limit order at nearest resistance + ATR buffer (1.5-5.0% range, 1:1.5-1:3 R:R)
   - **Stop Loss**: Stop-limit order at nearest support - ATR buffer (0.8-2.5% range)
   - **Adaptive**: Levels calculated based on actual market structure, not fixed percentages
   - **Automatic**: When one fills, the other cancels (handled by Binance)

**Tracking Lifecycle:**

```python
# app/models/trade.py - Trade model fields

# Entry Phase
status = 'pending'  â†’ Order submitted
status = 'filled'   â†’ Order executed

# Exit Phase (when OCO triggers)
status = 'closed'
exit_price = <fill price>
exit_reason = 'TAKE_PROFIT' | 'STOP_LOSS' | 'MANUAL' | 'TIMEOUT'
profit_loss = <net P&L after fees>
profit_loss_percentage = <P&L as % of entry value>
duration_seconds = <time position was open>
closed_at = <timestamp>
```

### **Position Monitoring**

**File:** `app/services/trading_bot.py`

**Method:** `_check_oco_orders()`
- Runs every 5 minutes (aligned with trading cycle)
- Checks status of all open OCO orders via Binance API
- Method: `binance_service.get_oco_order_status()`
- Enforces 8-hour maximum hold time (day trading timeout)
- When OCO status = 'ALL_DONE':
  - Extracts which leg filled (TP or SL)
  - Updates Trade record with exit details
  - Updates Portfolio with realized P&L
  - Removes position from RiskManager tracking
  - Deletes OpenPosition record

---

## ğŸ›¡ï¸ Risk Management System

**File:** `app/services/risk_manager.py`

### **Core Rules**

1. **Multiple Position Management**
   - Method: `validate_trade_signal()` checks `get_open_positions(user_id)`
   - Maximum 3 concurrent open positions per user (configurable via `MAX_OPEN_POSITIONS`)
   - No duplicate positions on the same trading pair (symbol)
   - Each position can be on a different symbol (e.g., BTCUSDT, ETHUSDT, SOLUSDT)

2. **Position Sizing**
   - Method: `calculate_position_size()`
   - Formula: `position_size = (balance * risk_pct / 100) / |entry_price - stop_loss_price|`
   - Default: 1% account risk per trade
   - Max: 1% of balance per position (strict safety limit)

3. **Daily Trade Limits**
   - Default: 5 trades per day per user (quality over quantity)
   - Tracked in-memory: `daily_trade_count[user_id]`
   - Method: `reset_daily_counters()` - Clears at midnight UTC

4. **Confidence Filter**
   - Minimum 75% AI confidence required (higher bar for day trading)
   - Constant: `MIN_SIGNAL_CONFIDENCE` in `service_constants.py`

5. **Balance Requirements**
   - Minimum: $10 USDT account balance
   - Minimum: $5 trade value
   - Constants: `MIN_ACCOUNT_BALANCE`, `MIN_TRADE_VALUE`

---

## â° Manual Trade Closing & Timeouts

### **Automatic Position Timeout**

**File:** `app/services/trading_bot.py`

**Timeout Threshold:** 8 hours (480 minutes) - Day trading maximum hold
- Constant: `POSITION_TIMEOUT_MINUTES = 480`
- Prevents overnight exposure while allowing intraday moves to develop

**What Happens:**

```python
# Method: _check_oco_orders()

For each open position:
    1. Check: position open > 30 minutes?
    2. YES â†’ Force close position:
       â”œâ”€â”€ Method: _force_close_stale_position()
       â”œâ”€â”€ Try to cancel OCO order:
       â”‚   â””â”€â”€ binance_service.cancel_oco_order() [uses _delete API]
       â”œâ”€â”€ Get current market price:
       â”‚   â””â”€â”€ binance_service.get_symbol_price()
       â”œâ”€â”€ Place market close order:
       â”‚   â””â”€â”€ binance_service.place_market_order()
       â”œâ”€â”€ Calculate P&L at current price
       â”œâ”€â”€ Update Trade record with exit details
       â””â”€â”€ Update Portfolio statistics
```

### **Manual Close via API**

**File:** `app/api/trading.py`

**Endpoint:** `POST /trading/close/{trade_id}`
- User-initiated position close
- Same flow as timeout close
- Reason: `exit_reason = 'MANUAL'`

---

## ğŸ• Trading Hours & Intervals

### **Operating Hours**
- **Active:** 24/7 (00:00 - 23:59 GMT) - Crypto markets never close
- **Configuration:** `app/config.py` â†’ `trading_active_hours_start` / `trading_active_hours_end`
- **Method:** `trading_bot._is_trading_hours()` - Checks before every cycle

**Day Trading Philosophy:**
- âœ… Continuous monitoring across all market sessions
- âœ… Captures opportunities in any timezone
- âœ… Open positions monitored round-the-clock
- âœ… 8-hour max hold prevents overnight exposure
- âœ… OCO orders always active on Binance

### **Timing Intervals**

| Action | Interval | File/Method |
|--------|----------|-------------|
| Main Trading Loop | **5 minutes** | `trading_bot.py` â†’ `trading_loop()` |
| OCO Order Check | **5 minutes** | `trading_bot.py` â†’ `_check_oco_orders()` |
| User Rate Limit | **5 minutes** | `trading_bot.py` â†’ `_remaining_rate_limit()` |
| Position Timeout | **8 hours** | `trading_bot.py` â†’ `_handle_oco_executing()` |
| Daily Counter Reset | **Midnight UTC** | `trading_bot.py` â†’ `daily_reset_task()` |

---

## ğŸ§  Multi-Timeframe AI Decision Making

**File:** `app/services/ai_analyzer.py`

### **Multi-Timeframe Analysis**

**Method:** `analyze_market_data_mtf(symbol, mtf_data, user_trade_history, regime_analysis)`
- Analyzes 3 timeframes simultaneously:
  - **15-minute:** Primary entry signals and trade setup
  - **1-hour:** Overall trend direction and momentum
  - **5-minute:** Precise entry timing
- Calculates timeframe confluence score (0-100)
- Higher confluence = stronger, more reliable signals

### **Support/Resistance Detection**

**Method:** `risk_manager.detect_support_resistance_levels(df, current_price)`
- Identifies key price levels using:
  - Pivot points (swing highs/lows)
  - Price clustering analysis
  - Touch counting (validation of levels)
- Used for adaptive stop-loss and take-profit placement

### **Adaptive Risk-Reward Calculation**

**Method:** `risk_manager.calculate_adaptive_risk_reward(side, entry_price, sr_levels, atr)`
- Places stops at support levels (buys) or resistance levels (sells)
- Adds ATR-based buffer for volatility protection
- Targets 1:1.5 minimum, 1:2 preferred, up to 1:3 R:R
- Dynamically adjusts based on actual market structure

### **Day Trading Focus: Current Market Only**

**Historical Data: DISABLED**
- Day trading requires focus on **current market conditions**, not past performance
- Historical data can create psychological bias and hesitation
- Each trade is evaluated purely on technical setup quality
- Removes emotional baggage from previous wins/losses

**Why This Matters:**
- Prevents "revenge trading" after losses
- Prevents overconfidence after wins
- Ensures objective analysis of each setup
- AI focuses on market structure, not user psychology

### **Day Trading AI Prompt**

**Method:** `_generate_mtf_prompt(primary_latest, mtf_summary, user_history, regime_analysis)`

**Includes:**
1. Multi-timeframe market data (15m/1h/5m)
2. Technical indicators (RSI, MACD, ADX, ATR, Bollinger Bands, Stochastic, OBV)
3. Timeframe confluence score
4. Market regime classification (trending/ranging/volatile)
5. Day trading specific instructions:
   - Favor trending markets with ADX > 25
   - Accept range-bound trades if confluence is high
   - Respect 1:1.5 minimum risk-reward
   - Quality over quantity (1-5 trades/day target)

**Result:** Pure technical analysis focused on current market structure and multi-timeframe alignment, free from historical performance bias

---

## ğŸ“ Key Files & Their Roles

### **Entry Point**
- `app/main.py` â†’ FastAPI app initialization, WebSocket endpoint, bot startup/shutdown

### **Trading Core**
- `app/services/trading_bot.py` â†’ Main trading loop, order execution, position monitoring
- `app/services/ai_analyzer.py` â†’ Market analysis, AI signal generation, historical context
- `app/services/risk_manager.py` â†’ Trade validation, position sizing, daily limits
- `app/services/binance_service.py` â†’ Binance API integration, order placement, price fetching
- `app/services/mock_binance_service.py` â†’ Simulated trading for testing (when `USE_MOCK_BINANCE=true`)
- `app/services/websocket_manager.py` â†’ Real-time notifications to frontend

### **API Routes**
- `app/api/auth.py` â†’ User registration, login, JWT tokens
- `app/api/trading.py` â†’ Start/stop trading, config updates, trade history
- `app/api/portfolio.py` â†’ Portfolio balance, performance stats

### **Database Models**
- `app/models/user.py` â†’ User accounts
- `app/models/trade.py` â†’ Trade records, TradingConfig, OpenPosition
- `app/models/portfolio.py` â†’ Portfolio balances, performance metrics (win rate, total P&L)

### **Configuration**
- `app/config.py` â†’ Environment variables, API keys, trading parameters
- `app/services/service_constants.py` â†’ Hardcoded constants (timeouts, ratios, limits)

---

## ğŸš€ Quick Start for Development

### **1. Setup Environment**
```bash
# Install dependencies
pip install -r requirements.txt

# Set environment variables in .env
BINANCE_API_KEY=your_key
BINANCE_SECRET_KEY=your_secret
BINANCE_TESTNET=true  # Safe mode
GEMINI_API_KEY=your_gemini_key
USE_MOCK_BINANCE=true  # For local testing without Binance
DATABASE_URL=postgresql+asyncpg://user:pass@localhost/trd_bot
```

### **2. Run Backend**
```bash
uvicorn app.main:app --reload --host 0.0.0.0 --port 8000
```

### **3. Test Trade Flow**
```bash
# Register user
POST /auth/register {"username": "test", "email": "test@test.com", "password": "password"}

# Login
POST /auth/login {"username": "test", "password": "password"}

# Start trading (requires JWT token)
POST /trading/start
Authorization: Bearer <token>

# Watch logs for trading activity
tail -f logs/trading_bot_2025-10-15.log
```

---

## ğŸ” Debugging Tips

### **Common Issues**

1. **"No active trading users found"**
   - Check: User called `POST /trading/start`?
   - Check: `TradingConfig.is_active = True` in database?

2. **"Outside trading hours"**
   - Check: Current time is 8AM-4PM GMT?
   - Verify: System timezone settings

3. **"User already has open position"**
   - Expected: Only 1 trade at a time allowed
   - Check: `OpenPosition` table for stuck positions

4. **"Trade rejected: insufficient balance"**
   - Check: USDT balance in Binance account
   - Check: Calculated position size vs. available balance

5. **"AI analyzer returned None"**
   - Check: Gemini API key valid?
   - Check: Gemini API rate limits

### **Useful Log Files**
- `logs/trading_bot_YYYY-MM-DD.log` â†’ Main bot activity
- `logs/trades_YYYY-MM-DD.log` â†’ Trade execution details
- `logs/metrics_YYYY-MM-DD.log` â†’ Performance metrics

---

## ğŸ“Š Database Schema Quick Reference

```sql
-- Active user check
SELECT * FROM trading_configs WHERE is_active = true;

-- View open positions
SELECT * FROM open_positions;

-- Recent trade history
SELECT * FROM trades WHERE user_id = 1 ORDER BY executed_at DESC LIMIT 10;

-- User performance
SELECT 
    user_id,
    total_trades,
    winning_trades,
    losing_trades,
    win_rate,
    total_realized_pnl
FROM portfolio WHERE user_id = 1;
```

---

## ğŸ¯ Architecture Highlights

**Design Patterns:**
- **Service Layer:** Business logic isolated in services (trading_bot, ai_analyzer, risk_manager)
- **Dependency Injection:** Services injected into TradingBot constructor
- **Mock Pattern:** `MockBinanceService` vs `BinanceService` for testing
- **Async/Await:** All database operations use SQLAlchemy AsyncSession

**Day Trading Safety Features:**
- Default testnet mode (`BINANCE_TESTNET=true`)
- Single-trade-at-a-time constraint
- 8-hour position timeout (prevents overnight exposure)
- 1% rule position sizing (risk-based, not capital-based)
- Adaptive stop-loss placement (support/resistance + ATR buffer)
- Minimum 1:1.5 risk-reward ratio enforcement
- Multi-timeframe confluence validation
- Pure technical analysis (no historical performance bias)
- Quality-focused trade selection (1-5 trades/day, not 10+)

**Real-Time Communication:**
- WebSocket per user (`/ws/{user_id}`)
- Notifications: AI analysis, trade execution, errors
- Manager tracks connections: `WebSocketManager.active_connections`

---

## ğŸ“š Further Reading

- `DAY_TRADING_COMPLETE_TRANSFORMATION.md` - **Complete transformation from scalping to day trading**
- `HISTORICAL_DATA_STRATEGY.md` - Original AI improvement plan
- `AI_IMPROVEMENT_STRATEGY.md` - Re-evaluated Phase 1 & 2 strategies
- `IMPLEMENTATION_SUMMARY.md` - Complete system analysis and changes
- `BUGFIX_GET_LATEST_PRICE.md` - Recent bug fix documentation

---

**Questions?** Check the inline code comments or trace the flow starting from `trading_bot.py â†’ trading_loop()`