# TRD Bot - AI-Powered Cryptocurrency Trading System
**Backend Documentation for New Developers**

---

## üéØ System Overview

An automated cryptocurrency **day trading bot** that uses AI (Google Gemini) to analyze market data and execute trades on Binance. The system follows a conservative **1% risk-per-trade strategy** with adaptive risk-reward based on support/resistance levels and multi-timeframe analysis.

**Tech Stack:** FastAPI + SQLAlchemy + PostgreSQL + Binance API + Google Gemini AI + WebSockets

---

## üìä Complete Trade Flow

### **Step-by-Step: How a Trade Happens**

```
1. User Registration (app/api/auth.py)
   ‚îú‚îÄ‚îÄ POST /auth/register ‚Üí Creates User + TradingConfig (is_active=False by default)
   ‚îî‚îÄ‚îÄ User receives JWT token

2. User Activates Trading (app/api/trading.py)
   ‚îú‚îÄ‚îÄ POST /trading/start ‚Üí Sets is_active=True in TradingConfig
   ‚îî‚îÄ‚îÄ User now joins the trading loop

3. Main Trading Loop (app/services/trading_bot.py)
   ‚îú‚îÄ‚îÄ Method: trading_loop() - Runs every 5 minutes (day trading cadence)
   ‚îú‚îÄ‚îÄ Method: _get_active_trading_configs() - Gets users with is_active=True
   ‚îî‚îÄ‚îÄ For each active user:
       ‚îÇ
       ‚îú‚îÄ‚Üí 4. Position Check
       ‚îÇ   ‚îú‚îÄ‚îÄ Method: _process_user_trading()
       ‚îÇ   ‚îú‚îÄ‚îÄ Check: Does user already have an open position?
       ‚îÇ   ‚îî‚îÄ‚îÄ YES ‚Üí Skip to next user | NO ‚Üí Continue
       ‚îÇ
       ‚îú‚îÄ‚Üí 5. Rate Limiting
       ‚îÇ   ‚îú‚îÄ‚îÄ Method: _remaining_rate_limit()
       ‚îÇ   ‚îú‚îÄ‚îÄ Check: Was user analyzed <5 minutes ago?
       ‚îÇ   ‚îî‚îÄ‚îÄ YES ‚Üí Skip to next user | NO ‚Üí Continue
       ‚îÇ
       ‚îú‚îÄ‚Üí 6. Multi-Timeframe Market Data Fetch (app/services/binance_service.py)
       ‚îÇ   ‚îú‚îÄ‚îÄ Method: _fetch_market_snapshot()
       ‚îÇ   ‚îú‚îÄ‚îÄ Fetches 3 timeframes for comprehensive analysis:
       ‚îÇ   ‚îÇ   ‚Ä¢ 15-minute (100 candles) - Primary entry signals
       ‚îÇ   ‚îÇ   ‚Ä¢ 1-hour (168 candles) - Trend context
       ‚îÇ   ‚îÇ   ‚Ä¢ 5-minute (288 candles) - Entry timing precision
       ‚îÇ   ‚îî‚îÄ‚îÄ Returns DataFrames for each timeframe
       ‚îÇ
       ‚îú‚îÄ‚Üí 7. Market Regime Analysis (app/services/market_regime_analyzer.py)
       ‚îÇ   ‚îú‚îÄ‚îÄ Method: classify_market_regime()
       ‚îÇ   ‚îú‚îÄ‚îÄ Analyzes: Trend strength (ADX), Volatility (ATR), Price action
       ‚îÇ   ‚îî‚îÄ‚îÄ Returns: Regime classification + trading permission
       ‚îÇ
       ‚îú‚îÄ‚Üí 8. Multi-Timeframe AI Analysis (app/services/ai_analyzer.py)
       ‚îÇ   ‚îú‚îÄ‚îÄ Method: analyze_market_data_mtf() - Multi-timeframe analysis
       ‚îÇ   ‚îú‚îÄ‚îÄ Method: calculate_technical_indicators() - RSI, MACD, ADX, ATR, Bollinger Bands
       ‚îÇ   ‚îú‚îÄ‚îÄ Method: _calculate_mtf_confluence() - Scores timeframe alignment (0-100)
       ‚îÇ   ‚îú‚îÄ‚îÄ Method: _generate_mtf_prompt() - Includes all timeframes + user history
       ‚îÇ   ‚îú‚îÄ‚îÄ Sends to Gemini AI (gemini-2.5-flash model)
       ‚îÇ   ‚îî‚îÄ‚îÄ Returns: {"signal": "buy/sell/hold", "confidence": 0-100, "entry_price", "stop_loss", "take_profit"}
       ‚îÇ
       ‚îú‚îÄ‚Üí 9. Signal Decision
       ‚îÇ   ‚îú‚îÄ‚îÄ Signal = "hold"? ‚Üí Skip to next user
       ‚îÇ   ‚îî‚îÄ‚îÄ Signal = "buy" or "sell"? ‚Üí Continue
       ‚îÇ
       ‚îú‚îÄ‚Üí 10. Balance Check (app/services/binance_service.py)
       ‚îÇ   ‚îú‚îÄ‚îÄ Method: get_account_balance()
       ‚îÇ   ‚îî‚îÄ‚îÄ Gets USDT available balance
       ‚îÇ
       ‚îú‚îÄ‚Üí 11. Risk Validation & Adaptive R:R (app/services/risk_manager.py)
       ‚îÇ   ‚îú‚îÄ‚îÄ Method: validate_trade_signal()
       ‚îÇ   ‚îú‚îÄ‚îÄ Method: detect_support_resistance_levels() - Identifies S/R zones
       ‚îÇ   ‚îú‚îÄ‚îÄ Method: calculate_adaptive_risk_reward() - Dynamic SL/TP placement
       ‚îÇ   ‚îú‚îÄ‚îÄ Checks:
       ‚îÇ   ‚îÇ   ‚Ä¢ User has no open positions (1 trade at a time rule)
       ‚îÇ   ‚îÇ   ‚Ä¢ Daily trade limit not exceeded (max 5/day)
       ‚îÇ   ‚îÇ   ‚Ä¢ AI confidence ‚â• 75% (day trading quality bar)
       ‚îÇ   ‚îÇ   ‚Ä¢ Sufficient account balance (‚â•$10 USDT)
       ‚îÇ   ‚îÇ   ‚Ä¢ Position size follows 1% rule
       ‚îÇ   ‚îÇ   ‚Ä¢ Risk-reward ratio ‚â• 1:1.5 (minimum acceptable)
       ‚îÇ   ‚îÇ   ‚Ä¢ Trade value ‚â•$10 and ‚â§3% of balance
       ‚îÇ   ‚îî‚îÄ‚îÄ PASS ‚Üí Continue | FAIL ‚Üí Reject + WebSocket notification
       ‚îÇ
       ‚îú‚îÄ‚Üí 12. Trade Execution (app/services/trading_bot.py)
       ‚îÇ   ‚îú‚îÄ‚îÄ Method: _execute_trade()
       ‚îÇ   ‚îú‚îÄ‚îÄ Step 1: Place order on Binance with Adaptive Exits
       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ File: app/services/binance_service.py
       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Method: place_order_with_oco()
       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Creates market entry order (BUY/SELL)
       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Places OCO exit order with S/R-based levels:
       ‚îÇ   ‚îÇ   ‚îÇ   ‚Ä¢ Take Profit: Nearest resistance + ATR buffer (1:1.5 to 1:3 R:R)
       ‚îÇ   ‚îÇ   ‚îÇ   ‚Ä¢ Stop Loss: Nearest support - ATR buffer (0.8-2.5% range)
       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ OCO executes automatically on Binance servers
       ‚îÇ   ‚îú‚îÄ‚îÄ Step 2: Create Trade record (app/models/trade.py)
       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Fields: symbol, side, amount, price, status='filled', ai_signal_confidence
       ‚îÇ   ‚îú‚îÄ‚îÄ Step 3: Create OpenPosition record (app/models/trade.py)
       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Fields: trade_id, oco_order_id, entry_price, stop_loss, take_profit
       ‚îÇ   ‚îú‚îÄ‚îÄ Step 4: Add to RiskManager in-memory tracking
       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Method: risk_manager.add_open_position()
       ‚îÇ   ‚îî‚îÄ‚îÄ Step 5: Send WebSocket notification to user
       ‚îÇ
       ‚îî‚îÄ‚Üí 13. Wait 5 minutes ‚Üí Loop back to Step 3
```

---

## üîÑ Order Placement & Tracking

### **OCO (One-Cancels-Other) Strategy**

Every trade uses OCO orders for automatic risk management:

**What Happens:**
1. **Entry Order** (Market Order)
   - Executes immediately at current price
   - File: `binance_service.py`, Method: `place_order_with_oco()`
   
2. **Exit Orders** (OCO - placed simultaneously with adaptive levels)
   - **Take Profit**: Limit order at nearest resistance + ATR buffer (1.5-5.0% range, 1:1.5-1:3 R:R)
   - **Stop Loss**: Stop-limit order at nearest support - ATR buffer (0.8-2.5% range)
   - **Adaptive**: Levels calculated based on actual market structure, not fixed percentages
   - **Automatic**: When one fills, the other cancels (handled by Binance)

**Tracking Lifecycle:**

```python
# app/models/trade.py - Trade model fields

# Entry Phase
status = 'pending'  ‚Üí Order submitted
status = 'filled'   ‚Üí Order executed

# Exit Phase (when OCO triggers)
status = 'closed'
exit_price = <fill price>
exit_reason = 'TAKE_PROFIT' | 'STOP_LOSS' | 'MANUAL' | 'TIMEOUT'
profit_loss = <net P&L after fees>
profit_loss_percentage = <P&L as % of entry value>
duration_seconds = <time position was open>
closed_at = <timestamp>
```

### **Position Monitoring**

**File:** `app/services/trading_bot.py`

**Method:** `_check_oco_orders()`
- Runs every 5 minutes (aligned with trading cycle)
- Checks status of all open OCO orders via Binance API
- Method: `binance_service.get_oco_order_status()`
- Enforces 8-hour maximum hold time (day trading timeout)
- When OCO status = 'ALL_DONE':
  - Extracts which leg filled (TP or SL)
  - Updates Trade record with exit details
  - Updates Portfolio with realized P&L
  - Removes position from RiskManager tracking
  - Deletes OpenPosition record

---

## üõ°Ô∏è Risk Management System

**File:** `app/services/risk_manager.py`

### **Core Rules**

1. **Multiple Position Management**
   - Method: `validate_trade_signal()` checks `get_open_positions(user_id)`
   - Maximum 3 concurrent open positions per user (configurable via `MAX_OPEN_POSITIONS`)
   - No duplicate positions on the same trading pair (symbol)
   - Each position can be on a different symbol (e.g., BTCUSDT, ETHUSDT, SOLUSDT)

2. **Position Sizing**
   - Method: `calculate_position_size()`
   - Formula: `position_size = (balance * risk_pct / 100) / |entry_price - stop_loss_price|`
   - Default: 1% account risk per trade
   - Max: 1% of balance per position (strict safety limit - see `MAX_BALANCE_TRADE_RATIO = 0.01`)

3. **Daily Trade Limits**
   - Default: 5 trades per day per user (quality over quantity)
   - Tracked in-memory: `daily_trade_count[user_id]`
   - Method: `reset_daily_counters()` - Clears at midnight UTC

4. **Confidence Filter (Adaptive)**
   - Base minimum: 60% AI confidence
   - **NEW:** Adaptive thresholds based on performance:
     - High win rate (>60%) ‚Üí Threshold lowered by 10 (more aggressive)
     - Low win rate (<40%) ‚Üí Threshold raised by 5 (more conservative)
     - Always randomized ¬±8% to prevent overfitting
   - Constant: `MIN_SIGNAL_CONFIDENCE = 60` in `service_constants.py`
   - Method: `risk_manager.get_adaptive_confidence_threshold()`

5. **Balance Requirements**
   - Minimum: $10 USDT account balance
   - Minimum: $5 trade value
   - Constants: `MIN_ACCOUNT_BALANCE`, `MIN_TRADE_VALUE`

6. **Anti-Overfitting Measures** üÜï
   - **Loosened thresholds:** S/R touch threshold: 0.5% (was 0.2%)
   - **Simplified confluence:** 3 core factors instead of 6 overlapping filters
   - **Parameter randomization:** All thresholds ¬±8-10% variance per trade
   - **Asset-specific profiles:** Different parameters for BTC/ETH/SOL/BNB
   - **Adaptive confidence:** Adjusts based on recent win rate
   - See: `OVERFITTING_ANALYSIS.md` and `ANTI_OVERFITTING_IMPLEMENTATION.md`


---

## ‚è∞ Manual Trade Closing & Timeouts

### **Automatic Position Timeout**

**File:** `app/services/trading_bot.py`

**Timeout Threshold:** 8 hours (480 minutes) - Day trading maximum hold
- Constant: `POSITION_TIMEOUT_MINUTES = 480`
- Prevents overnight exposure while allowing intraday moves to develop

**What Happens:**

```python
# Method: _check_oco_orders()

For each open position:
    1. Check: position open > 30 minutes?
    2. YES ‚Üí Force close position:
       ‚îú‚îÄ‚îÄ Method: _force_close_stale_position()
       ‚îú‚îÄ‚îÄ Try to cancel OCO order:
       ‚îÇ   ‚îî‚îÄ‚îÄ binance_service.cancel_oco_order() [uses _delete API]
       ‚îú‚îÄ‚îÄ Get current market price:
       ‚îÇ   ‚îî‚îÄ‚îÄ binance_service.get_symbol_price()
       ‚îú‚îÄ‚îÄ Place market close order:
       ‚îÇ   ‚îî‚îÄ‚îÄ binance_service.place_market_order()
       ‚îú‚îÄ‚îÄ Calculate P&L at current price
       ‚îú‚îÄ‚îÄ Update Trade record with exit details
       ‚îî‚îÄ‚îÄ Update Portfolio statistics
```

### **Manual Close via API**

**File:** `app/api/trading.py`

**Endpoint:** `POST /trading/close/{trade_id}`
- User-initiated position close
- Same flow as timeout close
- Reason: `exit_reason = 'MANUAL'`

---

## üïê Trading Hours & Intervals

### **Operating Hours**
- **Active:** 24/7 (00:00 - 23:59 GMT) - Crypto markets never close
- **Configuration:** `app/config.py` ‚Üí `trading_active_hours_start` / `trading_active_hours_end`
- **Method:** `trading_bot._is_trading_hours()` - Checks before every cycle

**Day Trading Philosophy:**
- ‚úÖ Continuous monitoring across all market sessions
- ‚úÖ Captures opportunities in any timezone
- ‚úÖ Open positions monitored round-the-clock
- ‚úÖ 8-hour max hold prevents overnight exposure
- ‚úÖ OCO orders always active on Binance

### **Timing Intervals**

| Action | Interval | File/Method |
|--------|----------|-------------|
| Main Trading Loop | **5 minutes** | `trading_bot.py` ‚Üí `trading_loop()` |
| OCO Order Check | **5 minutes** | `trading_bot.py` ‚Üí `_check_oco_orders()` |
| User Rate Limit | **5 minutes** | `trading_bot.py` ‚Üí `_remaining_rate_limit()` |
| Position Timeout | **8 hours** | `trading_bot.py` ‚Üí `_handle_oco_executing()` |
| Daily Counter Reset | **Midnight UTC** | `trading_bot.py` ‚Üí `daily_reset_task()` |

---

## üß† Multi-Timeframe AI Decision Making

**File:** `app/services/ai_analyzer.py`

### **Multi-Timeframe Analysis**

**Method:** `analyze_market_data_mtf(symbol, mtf_data, user_trade_history, regime_analysis)`
- Analyzes 3 timeframes simultaneously:
  - **15-minute:** Primary entry signals and trade setup
  - **1-hour:** Overall trend direction and momentum
  - **5-minute:** Precise entry timing
- Calculates timeframe confluence score (0-100)
- Higher confluence = stronger, more reliable signals

### **Support/Resistance Detection**

**Method:** `risk_manager.detect_support_resistance_levels(df, current_price)`
- Identifies key price levels using:
  - Pivot points (swing highs/lows)
  - Price clustering analysis
  - Touch counting (validation of levels)
- Used for adaptive stop-loss and take-profit placement

### **Adaptive Risk-Reward Calculation**

**Method:** `risk_manager.calculate_adaptive_risk_reward(side, entry_price, sr_levels, atr)`
- Places stops at support levels (buys) or resistance levels (sells)
- Adds ATR-based buffer for volatility protection
- Targets 1:1.5 minimum, 1:2 preferred, up to 1:3 R:R
- Dynamically adjusts based on actual market structure

### **Day Trading Focus: Current Market Only**

**Historical Data: DISABLED**
- Day trading requires focus on **current market conditions**, not past performance
- Historical data can create psychological bias and hesitation
- Each trade is evaluated purely on technical setup quality
- Removes emotional baggage from previous wins/losses

**Why This Matters:**
- Prevents "revenge trading" after losses
- Prevents overconfidence after wins
- Ensures objective analysis of each setup
- AI focuses on market structure, not user psychology

### **Day Trading AI Prompt**

**Method:** `_generate_mtf_prompt(primary_latest, mtf_summary, user_history, regime_analysis)`

**Includes:**
1. Multi-timeframe market data (15m/1h/5m)
2. Technical indicators (RSI, MACD, ADX, ATR, Bollinger Bands, Stochastic, OBV)
3. Timeframe confluence score
4. Market regime classification (trending/ranging/volatile)
5. Day trading specific instructions:
   - Favor trending markets with ADX > 25
   - Accept range-bound trades if confluence is high
   - Respect 1:1.5 minimum risk-reward
   - Quality over quantity (1-5 trades/day target)

**Result:** Pure technical analysis focused on current market structure and multi-timeframe alignment, free from historical performance bias

---

## üìÅ Key Files & Their Roles

### **Entry Point**
- `app/main.py` ‚Üí FastAPI app initialization, WebSocket endpoint, bot startup/shutdown

### **Trading Core**
- `app/services/trading_bot.py` ‚Üí Main trading loop, order execution, position monitoring
- `app/services/ai_analyzer.py` ‚Üí Market analysis, AI signal generation, historical context
- `app/services/risk_manager.py` ‚Üí Trade validation, position sizing, daily limits
- `app/services/binance_service.py` ‚Üí Binance API integration, order placement, price fetching
- `app/services/mock_binance_service.py` ‚Üí Simulated trading for testing (when `USE_MOCK_BINANCE=true`)
- `app/services/websocket_manager.py` ‚Üí Real-time notifications to frontend

### **API Routes**
- `app/api/auth.py` ‚Üí User registration, login, JWT tokens
- `app/api/trading.py` ‚Üí Start/stop trading, config updates, trade history
- `app/api/portfolio.py` ‚Üí Portfolio balance, performance stats

### **Database Models**
- `app/models/user.py` ‚Üí User accounts
- `app/models/trade.py` ‚Üí Trade records, TradingConfig, OpenPosition
- `app/models/portfolio.py` ‚Üí Portfolio balances, performance metrics (win rate, total P&L)

### **Configuration**
- `app/config.py` ‚Üí Environment variables, API keys, trading parameters
- `app/services/service_constants.py` ‚Üí Hardcoded constants (timeouts, ratios, limits)

#### **Per-Asset ATR Thresholds**
The system now supports **per-asset volatility calibration** for multi-symbol trading:

```python
# In service_constants.py
from app.services.service_constants import get_atr_thresholds

# Get thresholds for specific symbol
btc_thresholds = get_atr_thresholds("BTCUSDT")
# Returns: {"min": 0.40, "optimal_min": 0.50, "optimal_max": 1.20}

# Fallback to default for unconfigured assets
xrp_thresholds = get_atr_thresholds("XRPUSDT")
# Returns: BTCUSDT defaults
```

**Currently Configured Assets:**
- `BTCUSDT`: min=0.40%, optimal=0.50-1.20% (BTC volatility)
- `ETHUSDT`: min=0.50%, optimal=0.60-1.50% (Medium volatility)
- `BNBUSDT`: min=0.50%, optimal=0.60-1.40%
- `ADAUSDT`: min=0.60%, optimal=0.80-2.00% (Altcoin volatility)
- `SOLUSDT`: min=0.80%, optimal=1.00-2.50% (High volatility)
- `DOTUSDT`: min=0.60%, optimal=0.80-2.00%

**To Add New Assets:**
1. Edit `PER_ASSET_ATR_THRESHOLDS` dict in `service_constants.py`
2. Run `validate_constants()` at startup to verify ranges
3. Monitor logs for: `"Configured assets: BTCUSDT, ETHUSDT, ..."`

---

## üöÄ Quick Start for Development

### **1. Setup Environment**
```bash
# Install dependencies
pip install -r requirements.txt

# Set environment variables in .env
BINANCE_API_KEY=your_key
BINANCE_SECRET_KEY=your_secret
BINANCE_TESTNET=true  # Safe mode
GEMINI_API_KEY=your_gemini_key
USE_MOCK_BINANCE=true  # For local testing without Binance
DATABASE_URL=postgresql+asyncpg://user:pass@localhost/trd_bot
```

### **2. Run Backend**
```bash
uvicorn app.main:app --reload --host 0.0.0.0 --port 8000
```

### **3. Test Trade Flow**
```bash
# Register user
POST /auth/register {"username": "test", "email": "test@test.com", "password": "password"}

# Login
POST /auth/login {"username": "test", "password": "password"}

# Start trading (requires JWT token)
POST /trading/start
Authorization: Bearer <token>

# Watch logs for trading activity
tail -f logs/trading_bot_2025-10-15.log
```

---

## üîç Debugging Tips

### **Common Issues**

1. **"No active trading users found"**
   - Check: User called `POST /trading/start`?
   - Check: `TradingConfig.is_active = True` in database?

2. **"Outside trading hours"**
   - Check: Current time is 8AM-4PM GMT?
   - Verify: System timezone settings

3. **"User already has open position"**
   - Expected: Only 1 trade at a time allowed
   - Check: `OpenPosition` table for stuck positions

4. **"Trade rejected: insufficient balance"**
   - Check: USDT balance in Binance account
   - Check: Calculated position size vs. available balance

5. **"AI analyzer returned None"**
   - Check: Gemini API key valid?
   - Check: Gemini API rate limits

### **Useful Log Files**
- `logs/trading_bot_YYYY-MM-DD.log` ‚Üí Main bot activity
- `logs/trades_YYYY-MM-DD.log` ‚Üí Trade execution details
- `logs/metrics_YYYY-MM-DD.log` ‚Üí Performance metrics

---

## üìä Database Schema Quick Reference

```sql
-- Active user check
SELECT * FROM trading_configs WHERE is_active = true;

-- View open positions
SELECT * FROM open_positions;

-- Recent trade history
SELECT * FROM trades WHERE user_id = 1 ORDER BY executed_at DESC LIMIT 10;

-- User performance
SELECT 
    user_id,
    total_trades,
    winning_trades,
    losing_trades,
    win_rate,
    total_realized_pnl
FROM portfolio WHERE user_id = 1;
```

---

## üéØ Architecture Highlights

**Design Patterns:**
- **Service Layer:** Business logic isolated in services (trading_bot, ai_analyzer, risk_manager)
- **Dependency Injection:** Services injected into TradingBot constructor
- **Mock Pattern:** `MockBinanceService` vs `BinanceService` for testing
- **Async/Await:** All database operations use SQLAlchemy AsyncSession

**Day Trading Safety Features:**
- Default testnet mode (`BINANCE_TESTNET=true`)
- Single-trade-at-a-time constraint
- 8-hour position timeout (prevents overnight exposure)
- 1% rule position sizing (risk-based, not capital-based)
- Adaptive stop-loss placement (support/resistance + ATR buffer)
- Minimum 1:1.5 risk-reward ratio enforcement
- Multi-timeframe confluence validation
- Pure technical analysis (no historical performance bias)
- Quality-focused trade selection (1-5 trades/day, not 10+)

**Real-Time Communication:**
- WebSocket per user (`/ws/{user_id}`)
- Notifications: AI analysis, trade execution, errors
- Manager tracks connections: `WebSocketManager.active_connections`

---

## üìö Further Reading

- `DAY_TRADING_COMPLETE_TRANSFORMATION.md` - **Complete transformation from scalping to day trading**
- `HISTORICAL_DATA_STRATEGY.md` - Original AI improvement plan
- `AI_IMPROVEMENT_STRATEGY.md` - Re-evaluated Phase 1 & 2 strategies
- `IMPLEMENTATION_SUMMARY.md` - Complete system analysis and changes
- `BUGFIX_GET_LATEST_PRICE.md` - Recent bug fix documentation

---

**Questions?** Check the inline code comments or trace the flow starting from `trading_bot.py ‚Üí trading_loop()`